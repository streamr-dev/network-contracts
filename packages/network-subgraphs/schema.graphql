# TODO: how to define dates? This was suggested in https://graphql.org/learn/schema/
# scalar Date
# for now, use BigInt because that's what the events return

######################################################################
##  NETWORK: streams, (storage) nodes
######################################################################

type _Schema_
  @fulltext(
    name: "projectSearch"
    language: en
    algorithm: rank
    include: [{ entity: "Project", fields: [{ name: "metadata" }] }]
  )

type StreamPermission @entity {
  id: ID!
  "Ethereum address, owner of this permission"
  userAddress: Bytes!
  "Target stream this permission applies to"
  stream: Stream
  "Edit permission enables changing the stream's metadata"
  canEdit: Boolean
  "canDelete permission allows deleting the stream from the StreamRegistry"
  canDelete: Boolean
  "publishExpiration timestamp tells until what time this address may publish data to the stream"
  publishExpiration: BigInt
  "subscribeExpires timestamp tells until what time this address may subscribe to the stream"
  subscribeExpiration: BigInt
  "grant permission allows granting and revoking permissions to this stream"
  canGrant: Boolean
}

type Stream @entity {
  "stream ID = 'creator address'/'path' where path can be any string"
  id: ID!
  "Stream metadata JSON"
  metadata: String!
  "Permissions that each Ethereum address owns to this stream"
  permissions: [StreamPermission!] @derivedFrom(field: "stream")
  "Nodes the have been registered as storage nodes to this stream in the StreamStorageRegistry"
  storageNodes: [Node!] @derivedFrom(field: "storedStreams")
  "date created. This is a timestamp in seconds"
  createdAt: BigInt
  "date updated. This is a timestamp in seconds"
  updatedAt: BigInt
  sponsorships: [Sponsorship!] @derivedFrom(field: "stream")
}

type Node @entity {
  "node ID = address"
  id: ID!
  "Connection metadata, e.g. URL of the node, e.g. http://mynode.com:3000"
  metadata: String!
  "Epoch timestamp of the last time the node metadata was updated"
  lastSeen: BigInt!
  "Streams for which this node is registered as a storage node in the StreamStorageRegistry"
  storedStreams: [Stream!] # @derivedFrom(field: "storageNodes")
  # whitelisted: Boolean! # Problem: should whitelisting "create" nodes that show up in query results?
  "date created. This is a timestamp in seconds"
  createdAt: BigInt
}

# many-to-many relationship: https://thegraph.com/docs/developer/create-subgraph-hosted#many-to-many-relationships
# "more performant option" according the the docs:
# type StreamStorage @entity {
#   id: ID!
#   created: BigInt!
#   node: Node!
#   stream: Stream!
# }

############################################################
##  THE HUB: projects, marketplace, project-staking
############################################################

type ProjectPermission @entity {
  "permission id = projectId + '-' + userAddress"
  id: ID!
  "Ethereum address, owner of this permission"
  userAddress: Bytes!
  "Target project this permission applies to"
  project: Project!
  "canBuy permission enables a user to buy the project"
  canBuy: Boolean
  "canDelete permission allows deleting the project from the ProjectRegistry"
  canDelete: Boolean
  "canEdit permission enables changing the project's fields"
  canEdit: Boolean
  "canGrant permission allows granting and revoking permissions to this project"
  canGrant: Boolean
}

type ProjectPaymentDetails @entity {
  "payment details id = projectId + '-' + domainId"
  id: ID!
  "Target project this payment details applies to"
  project: Project!
  "The domainId of the chain where the project can be purchased. It's a unique id assigned by hyperlane to each chain"
  domainId: BigInt
  "Ethereum address, account where the payment is directed to for project purchases"
  beneficiary: Bytes!
  "Ethereum address, the token in which the payment goes to project beneficiary"
  pricingTokenAddress: Bytes!
  "Project price per second. This is a DATA-wei denominated amount (10^18th of DATA token)."
  pricePerSecond: BigInt
}

type ProjectSubscription @entity {
  "subscription id = projectId + '-' + subscriberAddress"
  id: ID!
  "Target project this permission applies to"
  project: Project!
  "Ethereum address, owner of this subscription"
  userAddress: Bytes!
  "Subscription expiration time. This is a timestamp in seconds"
  endTimestamp: BigInt
}

type Project @entity {
  "project id = bytes32"
  id: ID!
  "List of domain ids for the chains from which this project can be purchased"
  domainIds: [BigInt!]!
  "Payment details for the chains where the project can be purchased: mapping (uint32 => PaymentDetailsByChain)"
  paymentDetails: [ProjectPaymentDetails!]!
  "The minimum amount of seconds for which a subscription can be extended. This is a normal int value (not wei)"
  minimumSubscriptionSeconds: BigInt!
  "Subscriptions mapping (address => TimeBasedSubscription)"
  subscriptions: [ProjectSubscription!]!
  "Project metadata JSON"
  metadata: String!
  "Flags a project as being a data union, true iff 'isDataUnion' field is set to 'true' in the metadata JSON"
  isDataUnion: Boolean
  "Streams added to the project"
  streams: [String!]!
  "Permissions mapping (bytes32 => Permission)"
  permissions: [ProjectPermission!]!
  "date created. This is a timestamp in seconds"
  createdAt: BigInt
  "date updated. This is a timestamp in seconds"
  updatedAt: BigInt
  "Marketplace purchases"
  purchases: [ProjectPurchase!]!
  "Incremented/decremented when Stake/Unstake events are fired. It may not always be 1:1 with the stake (with future implementations)"
  score: BigInt!
  "Total tokens staked in the project by all stakers"
  stakedWei: BigInt!
  "Increases when various actions are triggered (e.g. purchase, stake, unstake). Used to generate unique ids"
  counter: Int
}

# MarketplaceV4

type ProjectPurchase @entity {
  "project purchase id = projectId + '-' + subscriberAddress + '-' + counter"
  id: ID!

  "Target project this purchase is for"
  project: Project!

  "Ethereum address, the account initiating the project purchase"
  subscriber: Bytes!

  "The amount of seconds by which the subscription is extended"
  subscriptionSeconds: BigInt!

  "The amount of tokens paid to beneficiary for project subscription"
  price: BigInt!

  "The amount of tokens paid to marketplace for project subscription"
  fee: BigInt!

  "purchase date. This is a timestamp in seconds"
  purchasedAt: BigInt
}

# ProjectStakingV1

type ProjectStakeByUser @entity {
  "stake id = projectId + '-' + userAddress"
  id: ID!

  "Target project this stake is for"
  project: Project!

  "Ethereum address, the account initiating the stake"
  user: Bytes!

  "All tokens staked by a given user"
  userStake: BigInt!
}

type ProjectStakingDayBucket @entity {
  "bucket id = projectId + '-' + date"
  id: ID!

  "Target project this stake is for"
  project: Project!

  "The day of the bucket"
  date: BigInt!

  "The amount of tokens staked when the bucket starts"
  stakeAtStart: BigInt!

  "The amount of tokens staked/unstaked on this day"
  stakeChange: BigInt!

  "The amount of tokens staked on this day"
  stakingsWei: BigInt!

  "The amount of tokens unstaked on this day"
  unstakingsWei: BigInt!
}

############################################################
##  OPERATOR TOKENOMICS: sponsoring, staking, delegating
##
##  Operators run the nodes that keep the streams humming
##  Sponsorships pay Operators for their work
##  Delegators signal their trust by delegating tokens to Operators
############################################################

type Operator @entity {
  id: ID! # contract address
  stakes: [Stake!]! @derivedFrom(field: "operator")
  delegators: [Delegation!]! @derivedFrom(field: "operator")
  slashingEvents: [SlashingEvent!]! @derivedFrom(field: "operator")
  stakingEvents: [StakingEvent!]! @derivedFrom(field: "operator")

  "All delegators who have delegated to this operator. Increased when Delegation is created and decreased when Delegation is removed"
  delegatorCount: Int!

  "DATA staked, earned and held by the Operator contract = totalStakeInSponsorshipsWei + freeFundsWei. Updated by PoolValueUpdate event, so might be out of date."
  poolValue: BigInt!

  "DATA staked and earned in sponsorship contracts. Updated by PoolValueUpdate event, so it will be out of date by the amount of earnings."
  totalStakeInSponsorshipsWei: BigInt!

  "DATA held by the operator, not yet staked. Updated by PoolValueUpdate event, so might be out of date if new DATA is sent via `ERC20.transfer`."
  freeFundsWei: BigInt!

  "Timestamp in seconds when poolValue was the best approximation of total DATA staked, earned and held by the Operator contract. Shows how much the poolValue is out of date."
  poolValueTimestamp: BigInt!

  "Block number after which poolValue was the best approximation of total DATA staked, earned and held by the Operator contract."
  poolValueBlockNumber: BigInt!

  "Total number of pool tokens in existence"
  poolTokenTotalSupplyWei: BigInt!

  "DATA/pooltoken exchange rate, equal to poolValue / totalSupply. Pool tokens are worth (exchangeRate * amount) DATA when undelegating."
  exchangeRate: BigDecimal!

  "Connection metadata, to be able to find a node in the Operator's fleet"
  latestHeartbeatMetadata: String
  latestHeartbeatTimestamp: BigInt

  "Total earnings excluding brokers shrare"
  cumulativeProfitsWei: BigInt!
  cumulativeOperatorsCutWei: BigInt!

  metadataJsonString: String! # TODO: unpack metadata to fields
  owner: String!
  slashingsCount: Int!
  nodes: [String!]!
  operatorsCutFraction: BigInt!

  flagsOpened: [Flag!]! @derivedFrom(field: "flagger")
  flagsTargeted: [Flag!]! @derivedFrom(field: "target")
}

type OperatorDailyBucket @entity {
  # absolute values, set at bucket creation time, so they represent the state after the first event in bucket
  id: ID! # operator address + date
  operator: Operator!

  "The day of the bucket. This is a timestamp in seconds"
  date: BigInt!

  "DATA staked, earned and held by the Operator contract = totalStakeInSponsorshipsWei + freeFundsWei (first event in bucket)"
  poolValue: BigInt!

  "DATA staked (slashed tokens are subtracted before the event is fired) in sponsorship contracts (first event in bucket)"
  totalStakeInSponsorshipsWei: BigInt!

  "DATA held by the operator, not yet staked (first event in bucket)"
  freeFundsWei: BigInt!

  "Momentary APY. Currently not used. TODO: calculate and add to subgraph"
  spotAPY: BigInt!

  "All delegators joining this operator. Initialized from operator.delegatorCount"
  delegatorCountAtStart: Int!

  # accumulated values, updated when events are fired
  "Delegators joining this operator on this day. Updated when Delegation entity is created"
  delegatorCountChange: Int!

  "All DATA tokens delegated to this operator, by all delegators. Updated when Delegated event is fired"
  totalDelegatedWei: BigInt!

  "Total DATA tokens undelegated from this operator, by all delegators. Updated when Undelegated event is fired"
  totalUndelegatedWei: BigInt!

  "Sum of earnings during the bucket, less operator's share"
  profitsWei: BigInt!

  "Sum of losses during the bucket"
  lossesWei: BigInt!

  "Sum of operator's share of earnings during the bucket"
  operatorsCutWei: BigInt!
}

# Delegation in an Operator contract signals trust in the operator
type Delegation @entity {
  id: ID! # 0xoperatorAddress-0xdelegatorAddress
  operator: Operator
  delegator: String!
  "Pool tokens held by a delegator in this Operator contract"
  poolTokenWei: BigInt!
}

# Sponsorship contracts hold tokens sent by sponsors and distribute them to the Operators who hold Stake in the contract
type Sponsorship @entity {
  id: ID! # sponsorship address
  stream: Stream
  metadata: String
  isRunning: Boolean!
  totalPayoutWeiPerSec: BigInt!
  stakes: [Stake!]! @derivedFrom(field: "sponsorship")
  slashingEvents: [SlashingEvent!]! @derivedFrom(field: "sponsorship")
  stakingEvents: [StakingEvent!]! @derivedFrom(field: "sponsorship")
  sponsoringEvents: [SponsoringEvent!]! @derivedFrom(field: "sponsorship")
  cumulativeSponsoring: BigInt!
  operatorCount: Int!
  totalStakedWei: BigInt!
  unallocatedWei: BigInt!
  spotAPY: BigInt!
  projectedInsolvency: BigInt!
  flags: [Flag!]! @derivedFrom(field: "sponsorship")
  creator: String!
  minimumStakingPeriodSeconds: BigInt!
}

type SponsorshipDailyBucket @entity {
  id: ID! # 0xSponsorshipAddress-TIMESTAMP
  sponsorship: Sponsorship!
  date: BigInt!
  totalStakedWei: BigInt!
  unallocatedWei: BigInt!
  projectedInsolvency: BigInt!
  spotAPY: BigInt!
  operatorCount: Int!
}

type SlashingEvent @entity {
  id: ID! # 0xSponsorshipAddress-0xOperatorAddress
  operator: Operator!
  amount: BigInt!
  date: BigInt!
  sponsorship: Sponsorship!
}

type StakingEvent @entity {
  id: ID! # 0xSponsorshipAddress-0xTransactionHash
  operator: Operator!
  amount: BigInt!
  date: BigInt!
  sponsorship: Sponsorship!
}

type SponsoringEvent @entity {
  id: ID!
  sponsor: String!
  amount: BigInt!
  sponsorship: Sponsorship!
  date: BigInt!
}

type QueueEntry @entity {
  id: ID! # 0xSponsorshipAddress-QueueIndex
  operator: Operator!
  amount: BigInt!
  date: BigInt!
  delegator: String!
}

# Operators hold Stake in Sponsorships
type Stake @entity {
  id: ID! # 0xSponsorshipAddress-0xOperatorAddress
  operator: Operator!
  amount: BigInt!
  allocatedWei: BigInt!
  date: BigInt
  sponsorship: Sponsorship
  joinDate: BigInt!
}

# Operators may raise Flags on each other to kick out those who don't do work
type Flag @entity {
  id: ID! # 0xsponsorshipAddress-0xoperatorAddress
  flagger: Operator!
  target: Operator!
  date: BigInt
  sponsorship: Sponsorship
  result: BigInt! # 0: pending, 1: target kicked, 2: flag failed
  targetSlashAmount: BigInt
}
