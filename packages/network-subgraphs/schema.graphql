# TODO: how to define dates? This was suggested in https://graphql.org/learn/schema/
# scalar Date

######################################################################
##  NETWORK: streams, (storage) nodes
######################################################################

type _Schema_
  @fulltext(
    name: "projectSearch"
    language: en
    algorithm: rank
    include: [{ entity: "Project", fields: [{ name: "metadata" }] }]
  )

type StreamPermission @entity {
  id: ID!
  "Ethereum address, owner of this permission"
  userAddress: Bytes!
  "Target stream this permission applies to"
  stream: Stream
  "Edit permission enables changing the stream's metadata"
  canEdit: Boolean
  "canDelete permission allows deleting the stream from the StreamRegistry"
  canDelete: Boolean
  "publishExpiration timestamp tells until what time this address may publish data to the stream"
  publishExpiration: BigInt
  "subscribeExpires timestamp tells until what time this address may subscribe to the stream"
  subscribeExpiration: BigInt
  "grant permission allows granting and revoking permissions to this stream"
  canGrant: Boolean
}

type Stream @entity {
  "stream ID = 'creator address'/'path' where path can be any string"
  id: ID!
  "Stream metadata JSON"
  metadata: String!
  "Permissions that each Ethereum address owns to this stream"
  permissions: [StreamPermission!] @derivedFrom(field: "stream")
  "Nodes the have been registered as storage nodes to this stream in the StreamStorageRegistry"
  storageNodes: [Node!] @derivedFrom(field: "storedStreams")
  "date created. This is a timestamp in seconds"
  createdAt: BigInt
  "date updated. This is a timestamp in seconds"
  updatedAt: BigInt
  sponsorships: [Sponsorship!] @derivedFrom(field: "stream")
}

type Node @entity {
  "node ID = address"
  id: ID!
  "Connection metadata, e.g. URL of the node, e.g. http://mynode.com:3000"
  metadata: String!
  "Epoch timestamp of the last time the node metadata was updated"
  lastSeen: BigInt!
  "Streams for which this node is registered as a storage node in the StreamStorageRegistry"
  storedStreams: [Stream!] # @derivedFrom(field: "storageNodes")
  # whitelisted: Boolean! # Problem: should whitelisting "create" nodes that show up in query results?
  "date created. This is a timestamp in seconds"
  createdAt: BigInt
}

# many-to-many relationship: https://thegraph.com/docs/developer/create-subgraph-hosted#many-to-many-relationships
# "more performant option" according the the docs:
# type StreamStorage @entity {
#   id: ID!
#   created: BigInt!
#   node: Node!
#   stream: Stream!
# }

############################################################
##  THE HUB: projects, marketplace, project-staking
############################################################

type ProjectPermission @entity {
  "permission id = projectId + '-' + userAddress"
  id: ID!
  "Ethereum address, owner of this permission"
  userAddress: Bytes!
  "Target project this permission applies to"
  project: Project!
  "canBuy permission enables a user to buy the project"
  canBuy: Boolean
  "canDelete permission allows deleting the project from the ProjectRegistry"
  canDelete: Boolean
  "canEdit permission enables changing the project's fields"
  canEdit: Boolean
  "canGrant permission allows granting and revoking permissions to this project"
  canGrant: Boolean
}

type ProjectPaymentDetails @entity {
  "payment details id = projectId + '-' + domainId"
  id: ID!
  "Target project this payment details applies to"
  project: Project!
  "The domainId of the chain where the project can be purchased. It's a unique id assigned by hyperlane to each chain"
  domainId: BigInt
  "Ethereum address, account where the payment is directed to for project purchases"
  beneficiary: Bytes!
  "Ethereum address, the token in which the payment goes to project beneficiary"
  pricingTokenAddress: Bytes!
  "Project price per second. This is a DATA-wei denominated amount (10^18th of DATA token)."
  pricePerSecond: BigInt
}

type ProjectSubscription @entity {
  "subscription id = projectId + '-' + subscriberAddress"
  id: ID!
  "Target project this permission applies to"
  project: Project!
  "Ethereum address, owner of this subscription"
  userAddress: Bytes!
  "Subscription expiration time. This is a timestamp in seconds"
  endTimestamp: BigInt
}

type Project @entity {
  "project id = bytes32"
  id: ID!
  "List of domain ids for the chains from which this project can be purchased"
  domainIds: [BigInt!]!
  "Payment details for the chains where the project can be purchased: mapping (uint32 => PaymentDetailsByChain)"
  paymentDetails: [ProjectPaymentDetails!]!
  "The minimum amount of seconds for which a subscription can be extended. This is a normal int value (not wei)"
  minimumSubscriptionSeconds: BigInt!
  "Subscriptions mapping (address => TimeBasedSubscription)"
  subscriptions: [ProjectSubscription!]!
  "Project metadata JSON"
  metadata: String!
  "Flags a project as being a data union, true iff 'isDataUnion' field is set to 'true' in the metadata JSON"
  isDataUnion: Boolean
  "Streams added to the project"
  streams: [String!]!
  "Permissions mapping (bytes32 => Permission)"
  permissions: [ProjectPermission!]!
  "date created. This is a timestamp in seconds"
  createdAt: BigInt
  "date updated. This is a timestamp in seconds"
  updatedAt: BigInt
  "Marketplace purchases"
  purchases: [ProjectPurchase!]!
  "Incremented/decremented when Stake/Unstake events are fired. It may not always be 1:1 with the stake (with future implementations)"
  score: BigInt!
  "Total tokens staked in the project by all stakers"
  stakedWei: BigInt!
  "Increases when various actions are triggered (e.g. purchase, stake, unstake). Used to generate unique ids"
  counter: Int
}

# MarketplaceV4

type ProjectPurchase @entity {
  "project purchase id = projectId + '-' + subscriberAddress + '-' + counter"
  id: ID!

  "Target project this purchase is for"
  project: Project!

  "Ethereum address, the account initiating the project purchase"
  subscriber: Bytes!

  "The amount of seconds by which the subscription is extended"
  subscriptionSeconds: BigInt!

  "The amount of tokens paid to beneficiary for project subscription"
  price: BigInt!

  "The amount of tokens paid to marketplace for project subscription"
  fee: BigInt!

  "purchase date. This is a timestamp in seconds"
  purchasedAt: BigInt
}

# ProjectStakingV1

type ProjectStakeByUser @entity {
  "stake id = projectId + '-' + userAddress"
  id: ID!

  "Target project this stake is for"
  project: Project!

  "Ethereum address, the account initiating the stake"
  user: Bytes!

  "All tokens staked by a given user"
  userStake: BigInt!
}

type ProjectStakingDayBucket @entity {
  "bucket id = projectId + '-' + date"
  id: ID!

  "Target project this stake is for"
  project: Project!

  "The day of the bucket"
  date: BigInt!

  "The amount of tokens staked when the bucket starts"
  stakeAtStart: BigInt!

  "The amount of tokens staked/unstaked on this day"
  stakeChange: BigInt!

  "The amount of tokens staked on this day"
  stakingsWei: BigInt!

  "The amount of tokens unstaked on this day"
  unstakingsWei: BigInt!
}

############################################################
##  OPERATOR TOKENOMICS: sponsoring, staking, delegating
##
##  Operators run the nodes that keep the streams humming
##  Sponsorships pay Operators for their work
##  Delegators signal their trust by delegating tokens to Operators
############################################################

type Operator @entity {
  id: ID! # contract address
  stakes: [Stake!]! @derivedFrom(field: "operator")
  delegators: [Delegation!]! @derivedFrom(field: "operator")
  delegatorCount: Int
  approximatePoolValue: BigInt!

  # TODO: unpack metadata to fields
  owner: String

  unallocatedWei: BigInt!
  flagsOpened: [Flag!]! @derivedFrom(field: "flagger")
  flagsTargeted: [Flag!]! @derivedFrom(field: "target")
}

type OperatorDailyBucket @entity {
  id: ID! # operator address + date
  operator: Operator!
  date: BigInt!
  approximatePoolValue: BigInt!
  unallocatedWei: BigInt!
  spotAPY: BigInt!
  totalPayoutsCumulative: BigInt!
  delegatorCount: Int!
  "Total DATA tokens delegated to this operator, by all delegators"
  totalDelegatedWei: BigInt!
  totalStakedWei: BigInt!
}

# Delegation in an Operator contract signals trust in the Operator
type Delegation @entity {
  id: ID! # 0xoperatorAddress-0xdelegatorAddress
  operator: Operator
  delegator: String!
  "Total amount of pooltokens held by a delegator"
  poolTokenWei: BigInt!
}

# Sponsorship contracts hold tokens sent by sponsors and distribute them to the Operators who hold Stake in the contract
type Sponsorship @entity {
  id: ID! # sponsorship address
  stream: Stream
  metadata: String
  isRunning: Boolean!
  totalPayoutWeiPerSec: BigInt!
  stakes: [Stake!]! @derivedFrom(field: "sponsorship")
  operatorCount: Int!
  totalStakedWei: BigInt!
  unallocatedWei: BigInt!
  projectedInsolvency: BigInt!
  flags: [Flag!]! @derivedFrom(field: "sponsorship")
}

type SponsorshipDailyBucket @entity {
  id: ID! # sponsorship address + date
  sponsorship: Sponsorship!
  date: BigInt!
  totalStakedWei: BigInt!
  unallocatedWei: BigInt!
  projectedInsolvency: BigInt!
  spotAPY: BigInt!
  totalPayoutsCumulative: BigInt!
  operatorCount: Int!
}

# Operators hold Stake in Sponsorships
type Stake @entity {
  id: ID! # 0xsponsorshipAddress-0xoperatorAddress
  operator: Operator!
  amount: BigInt!
  allocatedWei: BigInt!
  date: BigInt
  sponsorship: Sponsorship
}

# Operators may raise Flags on each other to kick out those who don't do work
type Flag @entity {
  id: ID! # 0xsponsorshipAddress-0xoperatorAddress
  flagger: Operator!
  target: Operator!
  date: BigInt
  sponsorship: Sponsorship
  result: BigInt! # 0: pending, 1: target kicked, 2: flag failed
  targetSlashAmount: BigInt
}
