# TODO: how to define dates/timestamps? This was suggested in https://graphql.org/learn/schema/
# scalar Date
# for now, use BigInt because that's what the events return
# TODO: frontend asked if we could give timestamps as numbers (not strings), so maybe try to use Int instead of BigInt?

######################################################################
##  NETWORK: streams, (storage) nodes
######################################################################

type _Schema_
  @fulltext(
    name: "projectSearch"
    language: en
    algorithm: rank
    include: [{ entity: "Project", fields: [{ name: "metadata" }] }]
  )

type StreamPermission @entity {
  id: ID!
  "Ethereum address, owner of this permission"
  userAddress: Bytes!
  "Target stream this permission applies to"
  stream: Stream
  "Edit permission enables changing the stream's metadata"
  canEdit: Boolean
  "canDelete permission allows deleting the stream from the StreamRegistry"
  canDelete: Boolean
  "publishExpiration timestamp tells until what time this address may publish data to the stream"
  publishExpiration: BigInt
  "subscribeExpires timestamp tells until what time this address may subscribe to the stream"
  subscribeExpiration: BigInt
  "grant permission allows granting and revoking permissions to this stream"
  canGrant: Boolean
}

type Stream @entity {
  "stream ID = 'creator address'/'path' where path can be any string"
  id: ID!
  "Stream metadata JSON"
  metadata: String!
  "Permissions that each Ethereum address owns to this stream"
  permissions: [StreamPermission!] @derivedFrom(field: "stream")
  "Nodes the have been registered as storage nodes to this stream in the StreamStorageRegistry"
  storageNodes: [Node!] @derivedFrom(field: "storedStreams")
  "date created. This is a timestamp in seconds"
  createdAt: BigInt
  "date updated. This is a timestamp in seconds"
  updatedAt: BigInt
  sponsorships: [Sponsorship!] @derivedFrom(field: "stream")
}

type Node @entity {
  "node ID = address"
  id: ID!
  "Connection metadata, e.g. URL of the node, e.g. http://mynode.com:3000"
  metadata: String!
  "Epoch timestamp of the last time the node metadata was updated"
  lastSeen: BigInt!
  "Streams for which this node is registered as a storage node in the StreamStorageRegistry"
  storedStreams: [Stream!] # @derivedFrom(field: "storageNodes")
  # whitelisted: Boolean! # Problem: should whitelisting "create" nodes that show up in query results?
  "date created. This is a timestamp in seconds"
  createdAt: BigInt
}

# many-to-many relationship: https://thegraph.com/docs/developer/create-subgraph-hosted#many-to-many-relationships
# "more performant option" according the the docs:
# type StreamStorage @entity {
#   id: ID!
#   created: BigInt!
#   node: Node!
#   stream: Stream!
# }

############################################################
##  THE HUB: projects, marketplace, project-staking
############################################################

type ProjectPermission @entity {
  "permission id = projectId + '-' + userAddress"
  id: ID!
  "Ethereum address, owner of this permission"
  userAddress: Bytes!
  "Target project this permission applies to"
  project: Project!
  "canBuy permission enables a user to buy the project"
  canBuy: Boolean
  "canDelete permission allows deleting the project from the ProjectRegistry"
  canDelete: Boolean
  "canEdit permission enables changing the project's fields"
  canEdit: Boolean
  "canGrant permission allows granting and revoking permissions to this project"
  canGrant: Boolean
}

type ProjectPaymentDetails @entity {
  "payment details id = projectId + '-' + domainId"
  id: ID!
  "Target project this payment details applies to"
  project: Project!
  "The domainId of the chain where the project can be purchased. It's a unique id assigned by hyperlane to each chain"
  domainId: BigInt
  "Ethereum address, account where the payment is directed to for project purchases"
  beneficiary: Bytes!
  "Ethereum address, the token in which the payment goes to project beneficiary"
  pricingTokenAddress: Bytes!
  "Project price per second. This is a DATA-wei denominated amount (10^18th of DATA token)."
  pricePerSecond: BigInt
}

type ProjectSubscription @entity {
  "subscription id = projectId + '-' + subscriberAddress"
  id: ID!
  "Target project this permission applies to"
  project: Project!
  "Ethereum address, owner of this subscription"
  userAddress: Bytes!
  "Subscription expiration time. This is a timestamp in seconds"
  endTimestamp: BigInt
}

type Project @entity {
  "project id = bytes32"
  id: ID!
  "List of domain ids for the chains from which this project can be purchased"
  domainIds: [BigInt!]!
  "Payment details for the chains where the project can be purchased: mapping (uint32 => PaymentDetailsByChain)"
  paymentDetails: [ProjectPaymentDetails!]!
  "The minimum amount of seconds for which a subscription can be extended. This is a normal int value (not wei)"
  minimumSubscriptionSeconds: BigInt!
  "Subscriptions mapping (address => TimeBasedSubscription)"
  subscriptions: [ProjectSubscription!]!
  "Project metadata JSON"
  metadata: String!
  "Flags a project as being a data union, true iff 'isDataUnion' field is set to 'true' in the metadata JSON"
  isDataUnion: Boolean
  "Streams added to the project"
  streams: [String!]!
  "Permissions mapping (bytes32 => Permission)"
  permissions: [ProjectPermission!]!
  "date created. This is a timestamp in seconds"
  createdAt: BigInt
  "date updated. This is a timestamp in seconds"
  updatedAt: BigInt
  "Marketplace purchases"
  purchases: [ProjectPurchase!]!
  "Incremented/decremented when Stake/Unstake events are fired. It may not always be 1:1 with the stake (with future implementations)"
  score: BigInt!
  "Total tokens staked in the project by all stakers"
  stakedWei: BigInt!
  "Increases when various actions are triggered (e.g. purchase, stake, unstake). Used to generate unique ids"
  counter: Int
}

# MarketplaceV4

type ProjectPurchase @entity {
  "project purchase id = projectId + '-' + subscriberAddress + '-' + counter"
  id: ID!

  "Target project this purchase is for"
  project: Project!

  "Ethereum address, the account initiating the project purchase"
  subscriber: Bytes!

  "The amount of seconds by which the subscription is extended"
  subscriptionSeconds: BigInt!

  "The amount of tokens paid to beneficiary for project subscription"
  price: BigInt!

  "The amount of tokens paid to marketplace for project subscription"
  fee: BigInt!

  "purchase date. This is a timestamp in seconds"
  purchasedAt: BigInt
}

# ProjectStakingV1

type ProjectStakeByUser @entity {
  "stake id = projectId + '-' + userAddress"
  id: ID!

  "Target project this stake is for"
  project: Project!

  "Ethereum address, the account initiating the stake"
  user: Bytes!

  "All tokens staked by a given user"
  userStake: BigInt!
}

type ProjectStakingDayBucket @entity {
  "bucket id = projectId + '-' + date"
  id: ID!

  "Target project this stake is for"
  project: Project!

  "The day of the bucket"
  date: BigInt!

  "The amount of tokens staked when the bucket starts"
  stakeAtStart: BigInt!

  "The amount of tokens staked/unstaked on this day"
  stakeChange: BigInt!

  "The amount of tokens staked on this day"
  stakingsWei: BigInt!

  "The amount of tokens unstaked on this day"
  unstakingsWei: BigInt!
}

############################################################
##  OPERATOR TOKENOMICS: sponsoring, staking, delegating
##
##  Operators run the nodes that keep the streams humming
##  Sponsorships pay Operators for their work
##  Delegators signal their trust by delegating tokens to Operators
############################################################

type Operator @entity {
  id: ID! # contract address
  stakes: [Stake!]! @derivedFrom(field: "operator")
  delegators: [Delegation!]! @derivedFrom(field: "operator")
  slashingEvents: [SlashingEvent!]! @derivedFrom(field: "operator")
  stakingEvents: [StakingEvent!]! @derivedFrom(field: "operator")
  raisedFlags: [Flag!]! @derivedFrom(field: "flagger")
  receivedFlags: [Flag!]! @derivedFrom(field: "target")

  "All delegators who have delegated to this operator. Increased when Delegation is created and decreased when Delegation is removed"
  delegatorCount: Int!

  "DATA staked + held by the Operator contract = totalStakeInSponsorshipsWei + dataTokenBalanceWei. Last updated at valueUpdateBlockNumber/Timestamp."
  valueWithoutEarnings: BigInt!

  "DATA staked into Sponsorship contracts. Last updated at valueUpdateBlockNumber/Timestamp."
  totalStakeInSponsorshipsWei: BigInt!

  "DATA held by the operator, not yet staked. Last updated at valueUpdateBlockNumber/Timestamp, might be out of date if new DATA is sent via `ERC20.transfer`."
  dataTokenBalanceWei: BigInt!

  "Timestamp in seconds when valueWithoutEarnings was updated. Shows how much the valueWithoutEarnings might be out of date."
  valueUpdateTimestamp: BigInt!

  "Block number when valueWithoutEarnings was updated."
  valueUpdateBlockNumber: BigInt!

  "Total number of operator tokens in existence"
  operatorTokenTotalSupplyWei: BigInt!

  "DATA/operatortoken exchange rate, equal to valueWithoutEarnings / totalSupply. Operator tokens are worth (exchangeRate * amount) DATA when undelegating."
  exchangeRate: BigDecimal!

  "Connection metadata, to be able to find a node in the Operator's fleet"
  latestHeartbeatMetadata: String
  latestHeartbeatTimestamp: BigInt

  "Increase in the Operator's value (cumulative, after fees)"
  cumulativeProfitsWei: BigInt!

  "Operator's share of the earnings (cumulative)"
  cumulativeOperatorsCutWei: BigInt!

  metadataJsonString: String!
  owner: String!
  slashingsCount: Int!
  nodes: [String!]!
  operatorsCutFraction: BigInt!

  flagsOpened: [Flag!]! @derivedFrom(field: "flagger")
  flagsTargeted: [Flag!]! @derivedFrom(field: "target")

  queueEntries: [QueueEntry!]! @derivedFrom(field: "operator")
}

type OperatorDailyBucket @entity {

  ## absolute values, set at bucket creation time, so they represent the state after the first event in bucket

  id: ID! # operator address + date
  operator: Operator!

  "The day of the bucket. This is a timestamp in seconds"
  date: BigInt!

  "DATA staked + held by the Operator contract = totalStakeInSponsorshipsWei + dataTokenBalanceWei (first event in bucket)"
  valueWithoutEarnings: BigInt!

  "DATA staked into Sponsorship contracts (first event in bucket)"
  totalStakeInSponsorshipsWei: BigInt!

  "DATA held by the operator, not yet staked (first event in bucket)"
  dataTokenBalanceWei: BigInt!

  "All delegators joining this operator. Initialized from operator.delegatorCount"
  delegatorCountAtStart: Int!


  ## accumulated values, updated when events are fired

  "Delegators that joined today. Updated when Delegation entity is created"
  delegatorCountChange: Int!

  "Sum of DATA tokens delegated to this operator today, by all delegators. Updated when Delegated event is fired"
  totalDelegatedWei: BigInt!

  "Sum of DATA tokens undelegated from this operator today, by all delegators. Updated when Undelegated event is fired"
  totalUndelegatedWei: BigInt!

  "Sum of earnings today, less operator's share"
  profitsWei: BigInt!

  "Sum of losses today"
  lossesWei: BigInt!

  "Sum of operator's share of earnings today"
  operatorsCutWei: BigInt!
}

# Delegation events in an Operator contract signals trust in the operator
type Delegation @entity {
  id: ID! # 0xoperatorAddress-0xdelegatorAddress
  operator: Operator
  delegator: String!

  "Amount of internal Operator tokens this delegator holds"
  operatorTokenBalanceWei: BigInt!

  "Amount of DATA tokens this delegator has moved into the Operator contract"
  delegatedDataWei: BigInt!

  "Amount of DATA tokens this delegator has moved out of the Operator contract"
  undelegatedDataWei: BigInt!
}

# Sponsorship contracts hold tokens sent by sponsors and distribute them to the Operators who hold Stake in the contract
type Sponsorship @entity {
  id: ID! # sponsorship address
  stream: Stream
  metadata: String
  isRunning: Boolean!
  totalPayoutWeiPerSec: BigInt!
  minimumStakingPeriodSeconds: BigInt!
  stakes: [Stake!]! @derivedFrom(field: "sponsorship")
  slashingEvents: [SlashingEvent!]! @derivedFrom(field: "sponsorship")
  stakingEvents: [StakingEvent!]! @derivedFrom(field: "sponsorship")
  sponsoringEvents: [SponsoringEvent!]! @derivedFrom(field: "sponsorship")
  cumulativeSponsoring: BigInt!
  operatorCount: Int!
  totalStakedWei: BigInt!
  remainingWei: BigInt!
  spotAPY: BigDecimal!
  projectedInsolvency: BigInt!
  flags: [Flag!]! @derivedFrom(field: "sponsorship")
  creator: String!
  maxOperators: Int
}

type SponsorshipDailyBucket @entity {
  id: ID! # 0xSponsorshipAddress-TIMESTAMP
  sponsorship: Sponsorship!
  date: BigInt!
  totalStakedWei: BigInt!
  remainingWei: BigInt!
  projectedInsolvency: BigInt!
  spotAPY: BigDecimal!
  operatorCount: Int!
}

# Operators hold Stake in Sponsorships. Stake is the "many-to-many table" between Sponsorship and Operator
type Stake @entity {
  id: ID! # 0xSponsorshipAddress-0xOperatorAddress
  sponsorship: Sponsorship!
  operator: Operator!
  amountWei: BigInt!
  lockedWei: BigInt!
  earningsWei: BigInt! # momentary earnings at updateTimestamp
  updateTimestamp: Int! # timestamp when earningsWei (and others) were updated; useful for calculating "real-time" earnings values
  joinTimestamp: Int!
  flagCount: Int! # how many times this operator has been flagged so far (failed flags + 0 or 1 pending)
}

# Operators may raise Flags on each other to kick out those who don't do work
type Flag @entity {
  id: ID! # 0xsponsorshipAddress-0xtargetOperatorAddress-flagIndex (derived from Stake.flagCount)
  sponsorship: Sponsorship!
  target: Operator!
  flagger: Operator!
  flaggingTimestamp: Int!
  result: String! # "waiting", "voting", "kicked", or "failed"
  votesForKick: BigInt!
  votesAgainstKick: BigInt!
  votes: [Vote!]! @derivedFrom(field: "flag")
  reviewerCount: Int!
  targetStakeAtRiskWei: BigInt!
  metadata: String!
}

type Vote @entity {
  id: ID! # 0xSponsorshipAddress-0xTargetOperatorAddress-flagIndex-0xReviewerAddress
  flag: Flag!
  voter: Operator!
  voterWeight: BigInt!
  timestamp: Int!
  votedKick: Boolean!
}

# Undelegation queue: when a delegator wants their DATA back, they are put in the queue to receive their tokens when they arrive
type QueueEntry @entity {
  id: ID! # 0xSponsorshipAddress-QueueIndex
  operator: Operator!
  amount: BigInt!
  date: BigInt!
  delegator: String!
}

# Plain events, saved "as-is". TODO: do we need and want them? Will they be expensive in the new decentralized subgraph?

type SponsoringEvent @entity {
  id: ID!
  sponsor: String!
  amount: BigInt!
  sponsorship: Sponsorship!
  date: BigInt!
}

type SlashingEvent @entity {
  id: ID!
  operator: Operator!
  amount: BigInt!
  date: BigInt!
  sponsorship: Sponsorship!
}

type StakingEvent @entity {
  id: ID!
  operator: Operator!
  amount: BigInt!
  date: BigInt!
  sponsorship: Sponsorship!
}