# TODO: how to define dates? This was suggested in https://graphql.org/learn/schema/
# scalar Date

type _Schema_
  @fulltext(
    name: "projectSearch"
    language: en
    algorithm: rank
    include: [{ entity: "Project", fields: [{ name: "metadata" }] }]
  )

type StreamPermission @entity {
  id: ID!
  "Ethereum address, owner of this permission"
  userAddress: Bytes!
  "Target stream this permission applies to"
  stream: Stream
  "Edit permission enables changing the stream's metadata"
  canEdit: Boolean
  "canDelete permission allows deleting the stream from the StreamRegistry"
  canDelete: Boolean
  "publishExpiration timestamp tells until what time this address may publish data to the stream"
  publishExpiration: BigInt
  "subscribeExpires timestamp tells until what time this address may subscribe to the stream"
  subscribeExpiration: BigInt
  "grant permission allows granting and revoking permissions to this stream"
  canGrant: Boolean
}

type Stream @entity {
  "stream ID = 'creator address'/'path' where path can be any string"
  id: ID!
  "Stream metadata JSON"
  metadata: String!
  "Permissions that each Ethereum address owns to this stream"
  permissions: [StreamPermission!] @derivedFrom(field: "stream")
  "Nodes the have been registered as storage nodes to this stream in the StreamStorageRegistry"
  storageNodes: [Node!] @derivedFrom(field: "storedStreams")
  "date created. This is a timestamp in seconds"
  createdAt: BigInt
  "date updated. This is a timestamp in seconds"
  updatedAt: BigInt
}

type Node @entity {
  "node ID = address"
  id: ID!
  "Connection metadata, e.g. URL of the node, e.g. http://mynode.com:3000"
  metadata: String!
  "Epoch timestamp of the last time the node metadata was updated"
  lastSeen: BigInt!
  "Streams for which this node is registered as a storage node in the StreamStorageRegistry"
  storedStreams: [Stream!] # @derivedFrom(field: "storageNodes")
  # whitelisted: Boolean! # Problem: should whitelisting "create" nodes that show up in query results?
  "date created. This is a timestamp in seconds"
  createdAt: BigInt
}

# many-to-many relationship: https://thegraph.com/docs/developer/create-subgraph-hosted#many-to-many-relationships
# "more performant option" according the the docs:
# type StreamStorage @entity {
#   id: ID!
#   created: BigInt!
#   node: Node!
#   stream: Stream!
# }

# Project Registry

type ProjectPermission @entity {
  "permission id = projectId + '-' + userAddress"
  id: ID!
  "Ethereum address, owner of this permission"
  userAddress: Bytes!
  "Target project this permission applies to"
  project: Project!
  "canBuy permission enables a user to buy the project"
  canBuy: Boolean
  "canDelete permission allows deleting the project from the ProjectRegistry"
  canDelete: Boolean
  "canEdit permission enables changing the project's fields"
  canEdit: Boolean
  "canGrant permission allows granting and revoking permissions to this project"
  canGrant: Boolean
}

type ProjectPaymentDetails @entity {
  "payment details id = projectId + '-' + domainId"
  id: ID!
  "Target project this payment details applies to"
  project: Project!
  "The domainId of the chain where the project can be purchased. It's a unique id assigned by hyperlane to each chain"
  domainId: BigInt
  "Ethereum address, account where the payment is directed to for project purchases"
  beneficiary: Bytes!
  "Ethereum address, the token in which the payment goes to project beneficiary"
  pricingTokenAddress: Bytes!
  "Project price per second. This is a DATA-wei denominated amount (10^18th of DATA token)."
  pricePerSecond: BigInt
}

type ProjectSubscription @entity {
  "subscription id = projectId + '-' + subscriberAddress"
  id: ID!
  "Target project this permission applies to"
  project: Project!
  "Ethereum address, owner of this subscription"
  userAddress: Bytes!
  "Subscription expiration time. This is a timestamp in seconds"
  endTimestamp: BigInt
}

type Project @entity {
  "project id = bytes32"
  id: ID!
  "List of domain ids for the chains from which this project can be purchased"
  domainIds: [BigInt!]!
  "Payment details for the chains where the project can be purchased: mapping (uint32 => PaymentDetailsByChain)"
  paymentDetails: [ProjectPaymentDetails!]!
  "The minimum amount of seconds for which a subscription can be extended. This is a normal int value (not wei)"
  minimumSubscriptionSeconds: BigInt!
  "Subscriptions mapping (address => TimeBasedSubscription)"
  subscriptions: [ProjectSubscription!]!
  "Project metadata JSON"
  metadata: String!
  "Flags a project as being a data union, true iff 'isDataUnion' field is set to 'true' in the metadata JSON"
  isDataUnion: Boolean
  "Streams added to the project"
  streams: [String!]!
  "Permissions mapping (bytes32 => Permission)"
  permissions: [ProjectPermission!]!
  "date created. This is a timestamp in seconds"
  createdAt: BigInt
  "date updated. This is a timestamp in seconds"
  updatedAt: BigInt
  "Marketplace purchases"
  purchases: [ProjectPurchase!]!
  "Incremented/decremented when Stake/Unstake events are fired. It may not always be 1:1 with the stake (with future implementations)"
  score: BigInt
  "Increases when various actions are triggered (e.g. purchase, stake, unstake). Used to generate unique ids"
  counter: Int
}

# MarketplaceV4

type ProjectPurchase @entity {
  "project purchase id = projectId + '-' + subscriberAddress + '-' + counter"
  id: ID!

  "Target project this purchase is for"
  project: Project!

  "Ethereum address, the account initiating the project purchase"
  subscriber: Bytes!

  "The amount of seconds by which the subscription is extended"
  subscriptionSeconds: BigInt!

  "The amount of tokens paid to beneficiary for project subscription"
  price: BigInt!

  "The amount of tokens paid to marketplace for project subscription"
  fee: BigInt!

  "purchase date. This is a timestamp in seconds"
  purchasedAt: BigInt
}

# ProjectStakingV1

type ProjectStaking @entity {
  "stake id = projectId + '-' + userAddress + '-' + counter"
  id: ID!

  "Target project this stake is for"
  project: Project!

  "Ethereum address, the account initiating the stake"
  user: Bytes!

  "The amount being staked"
  amount: BigInt!

  "stake date. This is a timestamp in seconds"
  stakedAt: BigInt
}

type ProjectUnstaking @entity {
  "unstake id = projectId + '-' + userAddress + '-' + counter"
  id: ID!

  "Target project this unstake is for"
  project: Project!

  "Ethereum address, the account initiating the unstake"
  user: Bytes!

  "The amount being unstaked"
  amount: BigInt!

  "unstake date. This is a timestamp in seconds"
  unstakedAt: BigInt
}

# Tatum

type Bounty @entity {
  id: ID! # bounty address
  isRunning: Boolean!
  stakes: [BountyStake!]! @derivedFrom(field: "bounty")
  brokerCount: Int!
  totalStakedWei: BigInt!
  unallocatedWei: BigInt!
  projectedInsolvency: BigInt!
  flags: [Flag!]! @derivedFrom(field: "bounty")
}

type BountyStake @entity {
  id: ID! # 0xbountyAddress-0xbrokerAddress
  broker: String!
  amount: BigInt!
  allocatedWei: BigInt!
  date: BigInt
  bounty: Bounty
  pool: BrokerPool
}

type Flag @entity {
  id: ID! # 0xbountyAddress-0xbrokerAddress
  flagger: BrokerPool!
  target: BrokerPool!
  # flagStake: BigInt! always fixed?
  date: BigInt
  bounty: Bounty
  result: BigInt! # 0: pending, 1: target kicked, 2: flag failed
  targetSlashAmount: BigInt
}

type BrokerPool @entity {
  id: ID! # pool address
  stakes: [BountyStake!]! @derivedFrom(field: "pool")
  delegators: [PoolDelegation!]! @derivedFrom(field: "pool")
  delegatorCount: Int
  approximatePoolValue: BigInt!
  unallocatedWei: BigInt!
  flagsOpened: [Flag!]! @derivedFrom(field: "flagger")
  flagsTargeted: [Flag!]! @derivedFrom(field: "target")
}

type PoolDelegation @entity {
  id: ID! # 0xpoolAddress-0xbrokerAddress
  delegator: String!
  amount: BigInt!
  pool: BrokerPool
}