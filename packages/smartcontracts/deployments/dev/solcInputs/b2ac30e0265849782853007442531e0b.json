{
  "language": "Solidity",
  "sources": {
    "contracts/chainlinkClient/ENSCache.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.6.0;\n\nimport \"@chainlink/contracts/src/v0.6/ChainlinkClient.sol\";\nimport \"@chainlink/contracts/src/v0.6/Chainlink.sol\";\nimport \"./Ownable.sol\";\n\ncontract ENSCache is ChainlinkClient, Ownable {\n  using Chainlink for Chainlink.Request;\n\n  uint256 constant private ORACLE_PAYMENT = 1 * LINK;\n\n  // address public resolvedEnsAddress;\n  mapping(string => address) public owners;\n  mapping(bytes32 => string) public sentRequests;\n  address public oracle;\n  string public jobId;\n\n  constructor(address oracleaddress, string memory chainlinkJobId) public {\n    setPublicChainlinkToken();\n    oracle = oracleaddress;\n    jobId = chainlinkJobId;\n  }\n\n  function setOracleAdress(address oracleAddress) public onlyOwner {\n    oracle = oracleAddress;\n  }\n\n  function setChainlinkJobId(string calldata chainlinkJobId) public onlyOwner {\n    jobId = chainlinkJobId;\n  }\n\n  function requestENSOwner(string calldata ensName) public onlyOwner {\n    Chainlink.Request memory req = buildChainlinkRequest(stringToBytes32(jobId), address(this), this.fulfillENSOwner.selector);\n    req.add(\"ensname\", ensName);\n    bytes32 requestid = sendChainlinkRequestTo(oracle, req, ORACLE_PAYMENT);\n    sentRequests[requestid] = ensName;\n  }\n\n  function fulfillENSOwner(bytes32 requestId, bytes32 owneraddress) public recordChainlinkFulfillment(requestId) {\n    //emit RequestEthereumLastMarket(_requestId, _market);\n    owners[sentRequests[requestId]] = address(uint160(uint256(owneraddress)));\n  }\n  \n  function getChainlinkToken() public view returns (address) {\n    return chainlinkTokenAddress();\n  }\n\n  function withdrawLink() public onlyOwner {\n    LinkTokenInterface link = LinkTokenInterface(chainlinkTokenAddress());\n    require(link.transfer(msg.sender, link.balanceOf(address(this))), \"Unable to transfer\");\n  }\n\n  function cancelRequest(bytes32 _requestId, uint256 _payment, bytes4 _callbackFunctionId,\n    uint256 _expiration) public onlyOwner {\n    cancelChainlinkRequest(_requestId, _payment, _callbackFunctionId, _expiration);\n  }\n  \n  function stringToBytes32(string memory source) private pure returns (bytes32 result) {\n    bytes memory tempEmptyStringTest = bytes(source);\n    if (tempEmptyStringTest.length == 0) {\n      return 0x0;\n    }\n\n    assembly { // solhint-disable-line no-inline-assembly\n      result := mload(add(source, 32))\n    }\n  }\n}"
    },
    "@chainlink/contracts/src/v0.6/ChainlinkClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"./Chainlink.sol\";\nimport \"./interfaces/ENSInterface.sol\";\nimport \"./interfaces/LinkTokenInterface.sol\";\nimport \"./interfaces/ChainlinkRequestInterface.sol\";\nimport \"./interfaces/PointerInterface.sol\";\nimport { ENSResolver as ENSResolver_Chainlink } from \"./vendor/ENSResolver.sol\";\n\n/**\n * @title The ChainlinkClient contract\n * @notice Contract writers can inherit this contract in order to create requests for the\n * Chainlink network\n */\ncontract ChainlinkClient {\n  using Chainlink for Chainlink.Request;\n\n  uint256 constant internal LINK = 10**18;\n  uint256 constant private AMOUNT_OVERRIDE = 0;\n  address constant private SENDER_OVERRIDE = address(0);\n  uint256 constant private ARGS_VERSION = 1;\n  bytes32 constant private ENS_TOKEN_SUBNAME = keccak256(\"link\");\n  bytes32 constant private ENS_ORACLE_SUBNAME = keccak256(\"oracle\");\n  address constant private LINK_TOKEN_POINTER = 0xC89bD4E1632D3A43CB03AAAd5262cbe4038Bc571;\n\n  ENSInterface private ens;\n  bytes32 private ensNode;\n  LinkTokenInterface private link;\n  ChainlinkRequestInterface private oracle;\n  uint256 private requestCount = 1;\n  mapping(bytes32 => address) private pendingRequests;\n\n  event ChainlinkRequested(bytes32 indexed id);\n  event ChainlinkFulfilled(bytes32 indexed id);\n  event ChainlinkCancelled(bytes32 indexed id);\n\n  /**\n   * @notice Creates a request that can hold additional parameters\n   * @param _specId The Job Specification ID that the request will be created for\n   * @param _callbackAddress The callback address that the response will be sent to\n   * @param _callbackFunctionSignature The callback function signature to use for the callback address\n   * @return A Chainlink Request struct in memory\n   */\n  function buildChainlinkRequest(\n    bytes32 _specId,\n    address _callbackAddress,\n    bytes4 _callbackFunctionSignature\n  ) internal pure returns (Chainlink.Request memory) {\n    Chainlink.Request memory req;\n    return req.initialize(_specId, _callbackAddress, _callbackFunctionSignature);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the stored oracle address\n   * @dev Calls `chainlinkRequestTo` with the stored oracle address\n   * @param _req The initialized Chainlink Request\n   * @param _payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendChainlinkRequest(Chainlink.Request memory _req, uint256 _payment)\n    internal\n    returns (bytes32)\n  {\n    return sendChainlinkRequestTo(address(oracle), _req, _payment);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the specified oracle address\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\n   * send LINK which creates a request on the target oracle contract.\n   * Emits ChainlinkRequested event.\n   * @param _oracle The address of the oracle for the request\n   * @param _req The initialized Chainlink Request\n   * @param _payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendChainlinkRequestTo(address _oracle, Chainlink.Request memory _req, uint256 _payment)\n    internal\n    returns (bytes32 requestId)\n  {\n    requestId = keccak256(abi.encodePacked(this, requestCount));\n    _req.nonce = requestCount;\n    pendingRequests[requestId] = _oracle;\n    emit ChainlinkRequested(requestId);\n    require(link.transferAndCall(_oracle, _payment, encodeRequest(_req)), \"unable to transferAndCall to oracle\");\n    requestCount += 1;\n\n    return requestId;\n  }\n\n  /**\n   * @notice Allows a request to be cancelled if it has not been fulfilled\n   * @dev Requires keeping track of the expiration value emitted from the oracle contract.\n   * Deletes the request from the `pendingRequests` mapping.\n   * Emits ChainlinkCancelled event.\n   * @param _requestId The request ID\n   * @param _payment The amount of LINK sent for the request\n   * @param _callbackFunc The callback function specified for the request\n   * @param _expiration The time of the expiration for the request\n   */\n  function cancelChainlinkRequest(\n    bytes32 _requestId,\n    uint256 _payment,\n    bytes4 _callbackFunc,\n    uint256 _expiration\n  )\n    internal\n  {\n    ChainlinkRequestInterface requested = ChainlinkRequestInterface(pendingRequests[_requestId]);\n    delete pendingRequests[_requestId];\n    emit ChainlinkCancelled(_requestId);\n    requested.cancelOracleRequest(_requestId, _payment, _callbackFunc, _expiration);\n  }\n\n  /**\n   * @notice Sets the stored oracle address\n   * @param _oracle The address of the oracle contract\n   */\n  function setChainlinkOracle(address _oracle) internal {\n    oracle = ChainlinkRequestInterface(_oracle);\n  }\n\n  /**\n   * @notice Sets the LINK token address\n   * @param _link The address of the LINK token contract\n   */\n  function setChainlinkToken(address _link) internal {\n    link = LinkTokenInterface(_link);\n  }\n\n  /**\n   * @notice Sets the Chainlink token address for the public\n   * network as given by the Pointer contract\n   */\n  function setPublicChainlinkToken() internal {\n    setChainlinkToken(PointerInterface(LINK_TOKEN_POINTER).getAddress());\n  }\n\n  /**\n   * @notice Retrieves the stored address of the LINK token\n   * @return The address of the LINK token\n   */\n  function chainlinkTokenAddress()\n    internal\n    view\n    returns (address)\n  {\n    return address(link);\n  }\n\n  /**\n   * @notice Retrieves the stored address of the oracle contract\n   * @return The address of the oracle contract\n   */\n  function chainlinkOracleAddress()\n    internal\n    view\n    returns (address)\n  {\n    return address(oracle);\n  }\n\n  /**\n   * @notice Allows for a request which was created on another contract to be fulfilled\n   * on this contract\n   * @param _oracle The address of the oracle contract that will fulfill the request\n   * @param _requestId The request ID used for the response\n   */\n  function addChainlinkExternalRequest(address _oracle, bytes32 _requestId)\n    internal\n    notPendingRequest(_requestId)\n  {\n    pendingRequests[_requestId] = _oracle;\n  }\n\n  /**\n   * @notice Sets the stored oracle and LINK token contracts with the addresses resolved by ENS\n   * @dev Accounts for subnodes having different resolvers\n   * @param _ens The address of the ENS contract\n   * @param _node The ENS node hash\n   */\n  function useChainlinkWithENS(address _ens, bytes32 _node)\n    internal\n  {\n    ens = ENSInterface(_ens);\n    ensNode = _node;\n    bytes32 linkSubnode = keccak256(abi.encodePacked(ensNode, ENS_TOKEN_SUBNAME));\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(ens.resolver(linkSubnode));\n    setChainlinkToken(resolver.addr(linkSubnode));\n    updateChainlinkOracleWithENS();\n  }\n\n  /**\n   * @notice Sets the stored oracle contract with the address resolved by ENS\n   * @dev This may be called on its own as long as `useChainlinkWithENS` has been called previously\n   */\n  function updateChainlinkOracleWithENS()\n    internal\n  {\n    bytes32 oracleSubnode = keccak256(abi.encodePacked(ensNode, ENS_ORACLE_SUBNAME));\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(ens.resolver(oracleSubnode));\n    setChainlinkOracle(resolver.addr(oracleSubnode));\n  }\n\n  /**\n   * @notice Encodes the request to be sent to the oracle contract\n   * @dev The Chainlink node expects values to be in order for the request to be picked up. Order of types\n   * will be validated in the oracle contract.\n   * @param _req The initialized Chainlink Request\n   * @return The bytes payload for the `transferAndCall` method\n   */\n  function encodeRequest(Chainlink.Request memory _req)\n    private\n    view\n    returns (bytes memory)\n  {\n    return abi.encodeWithSelector(\n      oracle.oracleRequest.selector,\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\n      _req.id,\n      _req.callbackAddress,\n      _req.callbackFunctionId,\n      _req.nonce,\n      ARGS_VERSION,\n      _req.buf.buf);\n  }\n\n  /**\n   * @notice Ensures that the fulfillment is valid for this contract\n   * @dev Use if the contract developer prefers methods instead of modifiers for validation\n   * @param _requestId The request ID for fulfillment\n   */\n  function validateChainlinkCallback(bytes32 _requestId)\n    internal\n    recordChainlinkFulfillment(_requestId)\n    // solhint-disable-next-line no-empty-blocks\n  {}\n\n  /**\n   * @dev Reverts if the sender is not the oracle of the request.\n   * Emits ChainlinkFulfilled event.\n   * @param _requestId The request ID for fulfillment\n   */\n  modifier recordChainlinkFulfillment(bytes32 _requestId) {\n    require(msg.sender == pendingRequests[_requestId],\n            \"Source must be the oracle of the request\");\n    delete pendingRequests[_requestId];\n    emit ChainlinkFulfilled(_requestId);\n    _;\n  }\n\n  /**\n   * @dev Reverts if the request is already pending\n   * @param _requestId The request ID for fulfillment\n   */\n  modifier notPendingRequest(bytes32 _requestId) {\n    require(pendingRequests[_requestId] == address(0), \"Request is already pending\");\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.6/Chainlink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport { CBORChainlink } from \"./vendor/CBORChainlink.sol\";\nimport { BufferChainlink } from \"./vendor/BufferChainlink.sol\";\n\n/**\n * @title Library for common Chainlink functions\n * @dev Uses imported CBOR library for encoding to buffer\n */\nlibrary Chainlink {\n  uint256 internal constant defaultBufferSize = 256; // solhint-disable-line const-name-snakecase\n\n  using CBORChainlink for BufferChainlink.buffer;\n\n  struct Request {\n    bytes32 id;\n    address callbackAddress;\n    bytes4 callbackFunctionId;\n    uint256 nonce;\n    BufferChainlink.buffer buf;\n  }\n\n  /**\n   * @notice Initializes a Chainlink request\n   * @dev Sets the ID, callback address, and callback function signature on the request\n   * @param self The uninitialized request\n   * @param _id The Job Specification ID\n   * @param _callbackAddress The callback address\n   * @param _callbackFunction The callback function signature\n   * @return The initialized request\n   */\n  function initialize(\n    Request memory self,\n    bytes32 _id,\n    address _callbackAddress,\n    bytes4 _callbackFunction\n  ) internal pure returns (Chainlink.Request memory) {\n    BufferChainlink.init(self.buf, defaultBufferSize);\n    self.id = _id;\n    self.callbackAddress = _callbackAddress;\n    self.callbackFunctionId = _callbackFunction;\n    return self;\n  }\n\n  /**\n   * @notice Sets the data for the buffer without encoding CBOR on-chain\n   * @dev CBOR can be closed with curly-brackets {} or they can be left off\n   * @param self The initialized request\n   * @param _data The CBOR data\n   */\n  function setBuffer(Request memory self, bytes memory _data)\n    internal pure\n  {\n    BufferChainlink.init(self.buf, _data.length);\n    BufferChainlink.append(self.buf, _data);\n  }\n\n  /**\n   * @notice Adds a string value to the request with a given key name\n   * @param self The initialized request\n   * @param _key The name of the key\n   * @param _value The string value to add\n   */\n  function add(Request memory self, string memory _key, string memory _value)\n    internal pure\n  {\n    self.buf.encodeString(_key);\n    self.buf.encodeString(_value);\n  }\n\n  /**\n   * @notice Adds a bytes value to the request with a given key name\n   * @param self The initialized request\n   * @param _key The name of the key\n   * @param _value The bytes value to add\n   */\n  function addBytes(Request memory self, string memory _key, bytes memory _value)\n    internal pure\n  {\n    self.buf.encodeString(_key);\n    self.buf.encodeBytes(_value);\n  }\n\n  /**\n   * @notice Adds a int256 value to the request with a given key name\n   * @param self The initialized request\n   * @param _key The name of the key\n   * @param _value The int256 value to add\n   */\n  function addInt(Request memory self, string memory _key, int256 _value)\n    internal pure\n  {\n    self.buf.encodeString(_key);\n    self.buf.encodeInt(_value);\n  }\n\n  /**\n   * @notice Adds a uint256 value to the request with a given key name\n   * @param self The initialized request\n   * @param _key The name of the key\n   * @param _value The uint256 value to add\n   */\n  function addUint(Request memory self, string memory _key, uint256 _value)\n    internal pure\n  {\n    self.buf.encodeString(_key);\n    self.buf.encodeUInt(_value);\n  }\n\n  /**\n   * @notice Adds an array of strings to the request with a given key name\n   * @param self The initialized request\n   * @param _key The name of the key\n   * @param _values The array of string values to add\n   */\n  function addStringArray(Request memory self, string memory _key, string[] memory _values)\n    internal pure\n  {\n    self.buf.encodeString(_key);\n    self.buf.startArray();\n    for (uint256 i = 0; i < _values.length; i++) {\n      self.buf.encodeString(_values[i]);\n    }\n    self.buf.endSequence();\n  }\n}\n"
    },
    "contracts/chainlinkClient/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nimport \"./Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () public {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is 0 address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.6/interfaces/ENSInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ninterface ENSInterface {\n\n  // Logged when the owner of a node assigns a new owner to a subnode.\n  event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n  // Logged when the owner of a node transfers ownership to a new account.\n  event Transfer(bytes32 indexed node, address owner);\n\n  // Logged when the resolver for a node changes.\n  event NewResolver(bytes32 indexed node, address resolver);\n\n  // Logged when the TTL of a node changes\n  event NewTTL(bytes32 indexed node, uint64 ttl);\n\n\n  function setSubnodeOwner(bytes32 node, bytes32 label, address _owner) external;\n  function setResolver(bytes32 node, address _resolver) external;\n  function setOwner(bytes32 node, address _owner) external;\n  function setTTL(bytes32 node, uint64 _ttl) external;\n  function owner(bytes32 node) external view returns (address);\n  function resolver(bytes32 node) external view returns (address);\n  function ttl(bytes32 node) external view returns (uint64);\n\n}\n"
    },
    "@chainlink/contracts/src/v0.6/interfaces/LinkTokenInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n  function approve(address spender, uint256 value) external returns (bool success);\n  function balanceOf(address owner) external view returns (uint256 balance);\n  function decimals() external view returns (uint8 decimalPlaces);\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n  function name() external view returns (string memory tokenName);\n  function symbol() external view returns (string memory tokenSymbol);\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n  function transfer(address to, uint256 value) external returns (bool success);\n  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\n}\n"
    },
    "@chainlink/contracts/src/v0.6/interfaces/ChainlinkRequestInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ninterface ChainlinkRequestInterface {\n  function oracleRequest(\n    address sender,\n    uint256 requestPrice,\n    bytes32 serviceAgreementID,\n    address callbackAddress,\n    bytes4 callbackFunctionId,\n    uint256 nonce,\n    uint256 dataVersion,\n    bytes calldata data\n  ) external;\n\n  function cancelOracleRequest(\n    bytes32 requestId,\n    uint256 payment,\n    bytes4 callbackFunctionId,\n    uint256 expiration\n  ) external;\n}\n"
    },
    "@chainlink/contracts/src/v0.6/interfaces/PointerInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ninterface PointerInterface {\n  function getAddress() external view returns (address);\n}\n"
    },
    "@chainlink/contracts/src/v0.6/vendor/ENSResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nabstract contract ENSResolver {\n  function addr(bytes32 node) public view virtual returns (address);\n}\n"
    },
    "@chainlink/contracts/src/v0.6/vendor/CBORChainlink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.19;\n\nimport { BufferChainlink } from \"./BufferChainlink.sol\";\n\nlibrary CBORChainlink {\n  using BufferChainlink for BufferChainlink.buffer;\n\n  uint8 private constant MAJOR_TYPE_INT = 0;\n  uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\n  uint8 private constant MAJOR_TYPE_BYTES = 2;\n  uint8 private constant MAJOR_TYPE_STRING = 3;\n  uint8 private constant MAJOR_TYPE_ARRAY = 4;\n  uint8 private constant MAJOR_TYPE_MAP = 5;\n  uint8 private constant MAJOR_TYPE_TAG = 6;\n  uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\n\n  uint8 private constant TAG_TYPE_BIGNUM = 2;\n  uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\n\n  function encodeType(\n    BufferChainlink.buffer memory buf,\n    uint8 major,\n    uint value\n  )\n    private\n    pure\n  {\n    if(value <= 23) {\n      buf.appendUint8(uint8((major << 5) | value));\n    } else if(value <= 0xFF) {\n      buf.appendUint8(uint8((major << 5) | 24));\n      buf.appendInt(value, 1);\n    } else if(value <= 0xFFFF) {\n      buf.appendUint8(uint8((major << 5) | 25));\n      buf.appendInt(value, 2);\n    } else if(value <= 0xFFFFFFFF) {\n      buf.appendUint8(uint8((major << 5) | 26));\n      buf.appendInt(value, 4);\n    } else if(value <= 0xFFFFFFFFFFFFFFFF) {\n      buf.appendUint8(uint8((major << 5) | 27));\n      buf.appendInt(value, 8);\n    }\n  }\n\n  function encodeIndefiniteLengthType(\n    BufferChainlink.buffer memory buf,\n    uint8 major\n  )\n    private\n    pure\n  {\n    buf.appendUint8(uint8((major << 5) | 31));\n  }\n\n  function encodeUInt(\n    BufferChainlink.buffer memory buf,\n    uint value\n  )\n    internal\n    pure\n  {\n    encodeType(buf, MAJOR_TYPE_INT, value);\n  }\n\n  function encodeInt(\n    BufferChainlink.buffer memory buf,\n    int value\n  )\n    internal\n    pure\n  {\n    if(value < -0x10000000000000000) {\n      encodeSignedBigNum(buf, value);\n    } else if(value > 0xFFFFFFFFFFFFFFFF) {\n      encodeBigNum(buf, value);\n    } else if(value >= 0) {\n      encodeType(buf, MAJOR_TYPE_INT, uint(value));\n    } else {\n      encodeType(buf, MAJOR_TYPE_NEGATIVE_INT, uint(-1 - value));\n    }\n  }\n\n  function encodeBytes(\n    BufferChainlink.buffer memory buf,\n    bytes memory value\n  )\n    internal\n    pure\n  {\n    encodeType(buf, MAJOR_TYPE_BYTES, value.length);\n    buf.append(value);\n  }\n\n  function encodeBigNum(\n    BufferChainlink.buffer memory buf,\n    int value\n  )\n    internal\n    pure\n  {\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\n    encodeBytes(buf, abi.encode(uint(value)));\n  }\n\n  function encodeSignedBigNum(\n    BufferChainlink.buffer memory buf,\n    int input\n  )\n    internal\n    pure\n  {\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM));\n    encodeBytes(buf, abi.encode(uint(-1 - input)));\n  }\n\n  function encodeString(\n    BufferChainlink.buffer memory buf,\n    string memory value\n  )\n    internal\n    pure\n  {\n    encodeType(buf, MAJOR_TYPE_STRING, bytes(value).length);\n    buf.append(bytes(value));\n  }\n\n  function startArray(\n    BufferChainlink.buffer memory buf\n  )\n    internal\n    pure\n  {\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\n  }\n\n  function startMap(\n    BufferChainlink.buffer memory buf\n  )\n    internal\n    pure\n  {\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\n  }\n\n  function endSequence(\n    BufferChainlink.buffer memory buf\n  )\n    internal\n    pure\n  {\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.6/vendor/BufferChainlink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\n/**\n* @dev A library for working with mutable byte buffers in Solidity.\n*\n* Byte buffers are mutable and expandable, and provide a variety of primitives\n* for writing to them. At any time you can fetch a bytes object containing the\n* current contents of the buffer. The bytes object should not be stored between\n* operations, as it may change due to resizing of the buffer.\n*/\nlibrary BufferChainlink {\n  /**\n  * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n  *      a capacity. The capacity may be longer than the current value, in\n  *      which case it can be extended without the need to allocate more memory.\n  */\n  struct buffer {\n    bytes buf;\n    uint capacity;\n  }\n\n  /**\n  * @dev Initializes a buffer with an initial capacity.\n  * @param buf The buffer to initialize.\n  * @param capacity The number of bytes of space to allocate the buffer.\n  * @return The buffer, for chaining.\n  */\n  function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\n    if (capacity % 32 != 0) {\n      capacity += 32 - (capacity % 32);\n    }\n    // Allocate space for the buffer data\n    buf.capacity = capacity;\n    assembly {\n      let ptr := mload(0x40)\n      mstore(buf, ptr)\n      mstore(ptr, 0)\n      mstore(0x40, add(32, add(ptr, capacity)))\n    }\n    return buf;\n  }\n\n  /**\n  * @dev Initializes a new buffer from an existing bytes object.\n  *      Changes to the buffer may mutate the original value.\n  * @param b The bytes object to initialize the buffer with.\n  * @return A new buffer.\n  */\n  function fromBytes(bytes memory b) internal pure returns(buffer memory) {\n    buffer memory buf;\n    buf.buf = b;\n    buf.capacity = b.length;\n    return buf;\n  }\n\n  function resize(buffer memory buf, uint capacity) private pure {\n    bytes memory oldbuf = buf.buf;\n    init(buf, capacity);\n    append(buf, oldbuf);\n  }\n\n  function max(uint a, uint b) private pure returns(uint) {\n    if (a > b) {\n      return a;\n    }\n    return b;\n  }\n\n  /**\n  * @dev Sets buffer length to 0.\n  * @param buf The buffer to truncate.\n  * @return The original buffer, for chaining..\n  */\n  function truncate(buffer memory buf) internal pure returns (buffer memory) {\n    assembly {\n      let bufptr := mload(buf)\n      mstore(bufptr, 0)\n    }\n    return buf;\n  }\n\n  /**\n  * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\n  *      the capacity of the buffer.\n  * @param buf The buffer to append to.\n  * @param off The start offset to write to.\n  * @param data The data to append.\n  * @param len The number of bytes to copy.\n  * @return The original buffer, for chaining.\n  */\n  function write(buffer memory buf, uint off, bytes memory data, uint len) internal pure returns(buffer memory) {\n    require(len <= data.length);\n\n    if (off + len > buf.capacity) {\n      resize(buf, max(buf.capacity, len + off) * 2);\n    }\n\n    uint dest;\n    uint src;\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Length of existing buffer data\n      let buflen := mload(bufptr)\n      // Start address = buffer address + offset + sizeof(buffer length)\n      dest := add(add(bufptr, 32), off)\n      // Update buffer length if we're extending it\n      if gt(add(len, off), buflen) {\n        mstore(bufptr, add(len, off))\n      }\n      src := add(data, 32)\n    }\n\n    // Copy word-length chunks while possible\n    for (; len >= 32; len -= 32) {\n      assembly {\n        mstore(dest, mload(src))\n      }\n      dest += 32;\n      src += 32;\n    }\n\n    // Copy remaining bytes\n    uint mask = 256 ** (32 - len) - 1;\n    assembly {\n      let srcpart := and(mload(src), not(mask))\n      let destpart := and(mload(dest), mask)\n      mstore(dest, or(destpart, srcpart))\n    }\n\n    return buf;\n  }\n\n  /**\n  * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n  *      the capacity of the buffer.\n  * @param buf The buffer to append to.\n  * @param data The data to append.\n  * @param len The number of bytes to copy.\n  * @return The original buffer, for chaining.\n  */\n  function append(buffer memory buf, bytes memory data, uint len) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, data, len);\n  }\n\n  /**\n  * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n  *      the capacity of the buffer.\n  * @param buf The buffer to append to.\n  * @param data The data to append.\n  * @return The original buffer, for chaining.\n  */\n  function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, data, data.length);\n  }\n\n  /**\n  * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\n  *      capacity of the buffer.\n  * @param buf The buffer to append to.\n  * @param off The offset to write the byte at.\n  * @param data The data to append.\n  * @return The original buffer, for chaining.\n  */\n  function writeUint8(buffer memory buf, uint off, uint8 data) internal pure returns(buffer memory) {\n    if (off >= buf.capacity) {\n      resize(buf, buf.capacity * 2);\n    }\n\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Length of existing buffer data\n      let buflen := mload(bufptr)\n      // Address = buffer address + sizeof(buffer length) + off\n      let dest := add(add(bufptr, off), 32)\n      mstore8(dest, data)\n      // Update buffer length if we extended it\n      if eq(off, buflen) {\n        mstore(bufptr, add(buflen, 1))\n      }\n    }\n    return buf;\n  }\n\n  /**\n  * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\n  *      capacity of the buffer.\n  * @param buf The buffer to append to.\n  * @param data The data to append.\n  * @return The original buffer, for chaining.\n  */\n  function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\n    return writeUint8(buf, buf.buf.length, data);\n  }\n\n  /**\n  * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\n  *      exceed the capacity of the buffer.\n  * @param buf The buffer to append to.\n  * @param off The offset to write at.\n  * @param data The data to append.\n  * @param len The number of bytes to write (left-aligned).\n  * @return The original buffer, for chaining.\n  */\n  function write(buffer memory buf, uint off, bytes32 data, uint len) private pure returns(buffer memory) {\n    if (len + off > buf.capacity) {\n      resize(buf, (len + off) * 2);\n    }\n\n    uint mask = 256 ** len - 1;\n    // Right-align data\n    data = data >> (8 * (32 - len));\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Address = buffer address + sizeof(buffer length) + off + len\n      let dest := add(add(bufptr, off), len)\n      mstore(dest, or(and(mload(dest), not(mask)), data))\n      // Update buffer length if we extended it\n      if gt(add(off, len), mload(bufptr)) {\n        mstore(bufptr, add(off, len))\n      }\n    }\n    return buf;\n  }\n\n  /**\n  * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\n  *      capacity of the buffer.\n  * @param buf The buffer to append to.\n  * @param off The offset to write at.\n  * @param data The data to append.\n  * @return The original buffer, for chaining.\n  */\n  function writeBytes20(buffer memory buf, uint off, bytes20 data) internal pure returns (buffer memory) {\n    return write(buf, off, bytes32(data), 20);\n  }\n\n  /**\n  * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\n  *      the capacity of the buffer.\n  * @param buf The buffer to append to.\n  * @param data The data to append.\n  * @return The original buffer, for chhaining.\n  */\n  function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, bytes32(data), 20);\n  }\n\n  /**\n  * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\n  *      the capacity of the buffer.\n  * @param buf The buffer to append to.\n  * @param data The data to append.\n  * @return The original buffer, for chaining.\n  */\n  function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, data, 32);\n  }\n\n  /**\n  * @dev Writes an integer to the buffer. Resizes if doing so would exceed\n  *      the capacity of the buffer.\n  * @param buf The buffer to append to.\n  * @param off The offset to write at.\n  * @param data The data to append.\n  * @param len The number of bytes to write (right-aligned).\n  * @return The original buffer, for chaining.\n  */\n  function writeInt(buffer memory buf, uint off, uint data, uint len) private pure returns(buffer memory) {\n    if (len + off > buf.capacity) {\n      resize(buf, (len + off) * 2);\n    }\n\n    uint mask = 256 ** len - 1;\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Address = buffer address + off + sizeof(buffer length) + len\n      let dest := add(add(bufptr, off), len)\n      mstore(dest, or(and(mload(dest), not(mask)), data))\n      // Update buffer length if we extended it\n      if gt(add(off, len), mload(bufptr)) {\n        mstore(bufptr, add(off, len))\n      }\n    }\n    return buf;\n  }\n\n  /**\n    * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n    * exceed the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer.\n    */\n  function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\n    return writeInt(buf, buf.buf.length, data, len);\n  }\n}\n"
    },
    "contracts/chainlinkClient/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/StreamRegistry/StreamRegistry.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"../chainlinkClient/ENSCache.sol\";\ncontract StreamRegistry {\n    event StreamCreated(string id, string metadata);\n    // event TransferedViewRights(uint streamid, address from, address to, uint8 amount);\n    // event TransferedPublishRights(uint streamid, address from, address to, uint8 amount);\n\n    enum PermissionType { Edit, Delete, Publish, Subscribe, Share }\n\n    mapping (string => uint32) private streamIdToVersion;\n    mapping (string => string) public streamIdToMetadata;\n    // streamid ->  keccak256(version, useraddress); -> permissions struct \n    mapping (string => mapping(bytes32 => Permission)) public streamIdToPermissions;\n    ENSCache private ensCache;\n\n    struct Permission {\n        bool edit;\n        bool canDelete;\n        bool publish; \n        bool subscribed;\n        bool share;\n    }\n\n    modifier canShare(string calldata streamId) {\n        require(streamIdToPermissions[streamId][getAddressKey(streamId, msg.sender)].share, \"no share permission\"); //||\n        _;\n    }\n    modifier canDelete(string calldata streamId) {\n        require(streamIdToPermissions[streamId][getAddressKey(streamId, msg.sender)].canDelete, \"no delete permission\"); //||\n        _;\n    }\n    modifier canEdit(string calldata streamId) {\n        require(streamIdToPermissions[streamId][getAddressKey(streamId, msg.sender)].edit, \"no edit permission\"); //||\n        _;\n    }\n    modifier streamExists(string calldata streamId) {\n        // TODO can stream exist without metadata?\n        require(bytes(streamIdToMetadata[streamId]).length != 0, \"stream does not exist\");\n        _;\n    }\n\n    constructor(address ensCacheAddr) public {\n        ensCache = ENSCache(ensCacheAddr);\n    }\n\n    function createStream(string calldata streamIdPath, string calldata metadataJsonString) public {\n        string memory ownerstring = addressToString(msg.sender);\n        _createStreamAndPermission(ownerstring, streamIdPath, metadataJsonString);\n    }\n\n    function createStreamWithENS(string calldata ensName, string calldata streamIdPath, string calldata metadataJsonString) public {\n        require(ensCache.owners(ensName) == msg.sender, \"you must be owner of the ensname\");\n        _createStreamAndPermission(ensName, streamIdPath, metadataJsonString);\n    }\n\n    function _createStreamAndPermission(string memory ownerstring, string calldata streamIdPath, string calldata metadataJsonString) internal {\n        bytes memory pathBytes = bytes(streamIdPath);\n        require(pathBytes[0] == \"/\", \"path must start with /\");\n        string memory streamId = string(abi.encodePacked(ownerstring, streamIdPath));\n        require(bytes(streamIdToMetadata[streamId]).length == 0, \"stream id alreay exists\");\n        streamIdToVersion[streamId] = streamIdToVersion[streamId] + 1;\n        streamIdToMetadata[streamId] = metadataJsonString;\n        streamIdToPermissions[streamId][getAddressKey(streamId, msg.sender)] = \n        Permission({\n            edit: true,\n            canDelete: true,\n            publish: true,\n            subscribed: true,\n            share: true\n        });\n        emit StreamCreated(streamId, metadataJsonString);\n    }\n\n    function getAddressKey(string memory streamId, address user) public view returns (bytes32) {\n        return keccak256(abi.encode(streamIdToVersion[streamId], user));\n    }\n\n    function updateStreamMetadata(string calldata streamId, string calldata metadata) public streamExists(streamId) canEdit(streamId) {\n        streamIdToMetadata[streamId] = metadata;\n    }\n\n    function getStreamMetadata(string calldata streamId) public view streamExists(streamId) returns (string memory des) {\n        return streamIdToMetadata[streamId];\n    }\n\n    function deleteStream(string calldata streamId) public streamExists(streamId) canDelete(streamId) {\n        delete streamIdToMetadata[streamId];\n    }\n\n    function getPermissionsForUser(string calldata streamId, address user) public view streamExists(streamId) returns (Permission memory permission) {\n        return streamIdToPermissions[streamId][getAddressKey(streamId, user)];\n    }\n\n    function setPermissionsForUser(string calldata streamId, address user, bool edit, \n        bool deletePerm, bool publish, bool subscribe, bool share) public canShare(streamId) {\n            streamIdToPermissions[streamId][getAddressKey(streamId, user)] = Permission({\n                edit: edit,\n                canDelete: deletePerm,\n                publish: publish,\n                subscribed: subscribe,\n                share: share\n           });\n    }\n\n    function revokePermissionsForUser(string calldata streamId, address user) public canShare(streamId){\n        delete streamIdToPermissions[streamId][getAddressKey(streamId, user)];\n    }\n\n    function hasPermission(string calldata streamId, address user, PermissionType permissionType) public view returns (bool userHasPermission) {\n        if (permissionType == PermissionType.Edit) {\n            return streamIdToPermissions[streamId][getAddressKey(streamId, user)].edit;\n        }\n        else if (permissionType == PermissionType.Delete) {\n            return streamIdToPermissions[streamId][getAddressKey(streamId, user)].canDelete;\n        }\n        else if (permissionType == PermissionType.Subscribe) {\n            return streamIdToPermissions[streamId][getAddressKey(streamId, user)].subscribed;\n        }\n        else if (permissionType == PermissionType.Publish) {\n            return streamIdToPermissions[streamId][getAddressKey(streamId, user)].publish;\n        }\n        else if (permissionType == PermissionType.Share) {\n            return streamIdToPermissions[streamId][getAddressKey(streamId, user)].share;\n        }\n    }\n\n    function grantPermission(string calldata streamId, address user, PermissionType permissionType) public canShare(streamId) {\n        setPermission(streamId, user, permissionType, true);\n    }\n\n    function revokePermission(string calldata streamId, address user, PermissionType permissionType) public canShare(streamId) {\n        setPermission(streamId, user, permissionType, false);\n    }\n\n    function setPermission(string calldata streamId, address user, PermissionType permissionType, bool grant) internal {\n        if (permissionType == PermissionType.Edit) {\n            streamIdToPermissions[streamId][getAddressKey(streamId, user)].edit = grant;\n        }\n        else if (permissionType == PermissionType.Delete) {\n            streamIdToPermissions[streamId][getAddressKey(streamId, user)].canDelete = grant;\n        }\n        else if (permissionType == PermissionType.Subscribe) {\n            streamIdToPermissions[streamId][getAddressKey(streamId, user)].subscribed = grant;\n        }\n        else if (permissionType == PermissionType.Publish) {\n            streamIdToPermissions[streamId][getAddressKey(streamId, user)].publish = grant;\n        }\n        else if (permissionType == PermissionType.Share) {\n            streamIdToPermissions[streamId][getAddressKey(streamId, user)].share = grant;\n        }\n    }\n\n    function addressToString(address _address) public pure returns(string memory) {\n       bytes32 _bytes = bytes32(uint256(uint160(_address)));\n       bytes memory _hex = \"0123456789abcdef\";\n       bytes memory _string = new bytes(42);\n       _string[0] = \"0\";\n       _string[1] = \"x\";\n       for(uint i = 0; i < 20; i++) {\n           _string[2+i*2] = _hex[uint8(_bytes[i + 12] >> 4)];\n           _string[3+i*2] = _hex[uint8(_bytes[i + 12] & 0x0f)];\n       }\n       return string(_string);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}